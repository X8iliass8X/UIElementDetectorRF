<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>UIElementDetectorRF - Documentation</title>
<style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #fff;
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            font-size: 2.5em;
            margin-top: 0;
        }
        h2 {
            color: #34495e;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 8px;
            margin-top: 40px;
            font-size: 1.8em;
        }
        h3 {
            color: #2980b9;
            margin-top: 30px;
            font-size: 1.4em;
        }
        h4 {
            color: #27ae60;
            margin-top: 25px;
            font-size: 1.2em;
        }
        .toc {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 20px;
            margin: 30px 0;
        }
        .toc h3 {
            margin-top: 0;
            color: #495057;
        }
        .toc ul {
            list-style-type: none;
            padding-left: 0;
        }
        .toc li {
            margin: 8px 0;
        }
        .toc a {
            text-decoration: none;
            color: #007bff;
            padding: 4px 8px;
            border-radius: 3px;
            transition: background-color 0.2s;
        }
        .toc a:hover {
            background-color: #e3f2fd;
        }
        pre {
            background: #f4f4f4;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 15px;
            overflow-x: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
            line-height: 1.4;
        }
        code {
            background: #f1f3f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
        }
        pre code {
            background: none;
            padding: 0;
        }
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .feature-card {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
        }
        .feature-card h4 {
            margin-top: 0;
            color: #495057;
        }
        .warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 6px;
            padding: 15px;
            margin: 20px 0;
        }
        .warning h4 {
            color: #856404;
            margin-top: 0;
        }
        .info {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            border-radius: 6px;
            padding: 15px;
            margin: 20px 0;
        }
        .info h4 {
            color: #0c5460;
            margin-top: 0;
        }
        .example {
            background: #e8f5e8;
            border: 1px solid #c3e6c3;
            border-radius: 6px;
            padding: 15px;
            margin: 20px 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        .pipeline {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #e3f2fd;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .pipeline-step {
            background: #2196f3;
            color: white;
            padding: 10px 15px;
            border-radius: 20px;
            font-weight: bold;
            margin: 5px;
        }
        .arrow {
            font-size: 20px;
            color: #2196f3;
            margin: 0 10px;
        }
        @media print {
            body { margin: 0; }
            .toc { break-inside: avoid; }
            pre { break-inside: avoid; }
            h1, h2, h3, h4 { break-after: avoid; }
        }
    </style>
</head>
<body>
<h1>UIElementDetectorRF - Documentation de la bibliothèque Robot Framework</h1>
<div class="toc">
<h3>Table des matières</h3>
<ul>
<li><a href="#overview">Aperçu</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#usage">Utilisation de base</a></li>
<li><a href="#keywords">Mots-clés de la bibliothèque</a></li>
<li><a href="#architecture">Architecture interne</a></li>
<li><a href="#result-structure">Structure du résultat de détection</a></li>
<li><a href="#examples">Exemples de tests complets</a></li>
<li><a href="#configuration">Options de configuration</a></li>
<li><a href="#troubleshooting">Dépannage</a></li>
<li><a href="#integration">Intégration avec les tests existants</a></li>
</ul>
</div>
<h2 id="overview">Aperçu</h2>
<p>UIElementDetectorRF is a Robot Framework library that combines computer vision (YOLO object detection) with web automation to intelligently detect and interact with UI elements. Unlike traditional automation that relies on brittle locators, this library uses AI to visually identify elements and automatically generates XPath selectors.</p>
<div class="feature-grid">
<div class="feature-card">
<h4>Visual Element Detection</h4>
<p>Uses YOLO deep learning models to detect buttons, inputs, dropdowns, checkboxes, and other UI elements</p>
</div>
<div class="feature-card">
<h4>Text-Based Matching</h4>
<p>Matches elements by associated text labels, button text, or placeholder text</p>
</div>
<div class="feature-card">
<h4>Full-Page Scanning</h4>
<p>Automatically scrolls and captures entire web pages for comprehensive element detection</p>
</div>
<div class="feature-card">
<h4>Proximity Detection</h4>
<p>Finds elements based on their spatial relationship to reference text</p>
</div>
<div class="feature-card">
<h4>Icon Recognition</h4>
<p>Detects icons by comparing with reference images</p>
</div>
<div class="feature-card">
<h4>Automatic XPath Generation</h4>
<p>Generates reliable XPath selectors for detected elements</p>
</div>
</div>
<h2 id="installation">Installation</h2>
<h3>Prerequisites</h3>
<ul>
<li><strong>Python 3.8+</strong></li>
<li><strong>Robot Framework</strong></li>
<li><strong>ChromeDriver</strong>: Download and install ChromeDriver compatible with your Chrome browser version</li>
</ul>
<h3>Required Dependencies</h3>
<pre><code># Install Robot Framework
pip install robotframework

# Install required dependencies
pip install opencv-python numpy selenium ultralytics pillow</code></pre>
<h3>Library Setup</h3>
<ol>
<li>Download the <code>UIElementDetectorRF.py</code> file</li>
<li>Place it in your Robot Framework project directory</li>
<li>Prepare a trained YOLO model for UI element detection (<code>.pt</code> file)</li>
</ol>
<h2 id="usage">Utilisation de base</h2>
<h3>Importation de la bibliothèque</h3>
<pre><code>*** Settings ***
Library    UIElementDetectorRF    /path/to/your/model.pt    /path/to/chromedriver</code></pre>
<h3>Exemple de test simple</h3>
<pre><code>*** Test Cases ***
Test Button Detection
    ${result}=    Detect Button By Text    https://example.com    Submit    0.7    True
    Should Not Be Equal    ${result}    ${None}
    ${xpath}=    Get Element XPath    ${result}
    Log    Found button at: ${xpath}
    Close Browser</code></pre>
<h2 id="keywords">Mots-clés de la bibliothèque</h2>
<h3>Mots-clés de détection</h3>
<h4>Detect Button By Text</h4>
<p>Detects a button by its text content.</p>
<table>
<tr><th>Argument</th><th>Description</th><th>Default</th></tr>
<tr><td>url</td><td>The URL to navigate to</td><td>Required</td></tr>
<tr><td>button_text</td><td>The text to search for in buttons</td><td>Required</td></tr>
<tr><td>confidence_threshold</td><td>Minimum confidence threshold</td><td>0.5</td></tr>
<tr><td>scan_full_page</td><td>Whether to scan the full page</td><td>True</td></tr>
</table>
<div class="example">
<pre><code>${result}=    Detect Button By Text    https://example.com    Login    0.6    True</code></pre>
</div>
<h4>Detect Input By Label</h4>
<p>Detects an input field by its associated label.</p>
<table>
<tr><th>Argument</th><th>Description</th><th>Default</th></tr>
<tr><td>url</td><td>The URL to navigate to</td><td>Required</td></tr>
<tr><td>label_text</td><td>The label text to search for</td><td>Required</td></tr>
<tr><td>confidence_threshold</td><td>Minimum confidence threshold</td><td>0.5</td></tr>
<tr><td>scan_full_page</td><td>Whether to scan the full page</td><td>True</td></tr>
</table>
<div class="example">
<pre><code>${result}=    Detect Input By Label    https://example.com    Email Address    0.7    True</code></pre>
</div>
<h4>Detect Dropdown By Text</h4>
<p>Detects a dropdown (select) element by option text or label.</p>
<table>
<tr><th>Argument</th><th>Description</th><th>Default</th></tr>
<tr><td>url</td><td>The URL to navigate to</td><td>Required</td></tr>
<tr><td>option_text</td><td>Text of an option in the dropdown</td><td>Optional</td></tr>
<tr><td>label_text</td><td>Label text associated with the dropdown</td><td>Optional</td></tr>
<tr><td>confidence_threshold</td><td>Minimum confidence threshold</td><td>0.5</td></tr>
<tr><td>scan_full_page</td><td>Whether to scan the full page</td><td>True</td></tr>
</table>
<div class="example">
<pre><code>${result}=    Detect Dropdown By Text    https://example.com    United States    Country    0.6</code></pre>
</div>
<h4>Detect Checkbox Radio By Text</h4>
<p>Detects checkbox or radio button by associated label text.</p>
<table>
<tr><th>Argument</th><th>Description</th><th>Default</th></tr>
<tr><td>url</td><td>The URL to navigate to</td><td>Required</td></tr>
<tr><td>label_text</td><td>The label text associated with the element</td><td>Required</td></tr>
<tr><td>element_type</td><td>Type to search for ('checkbox', 'radio', 'both')</td><td>both</td></tr>
<tr><td>confidence_threshold</td><td>Minimum confidence threshold</td><td>0.5</td></tr>
<tr><td>scan_full_page</td><td>Whether to scan the full page</td><td>True</td></tr>
</table>
<div class="example">
<pre><code>${result}=    Detect Checkbox Radio By Text    https://example.com    I agree to terms    checkbox    0.7</code></pre>
</div>
<h4>Detect Element By Proximity</h4>
<p>Detects an element by its proximity to reference text.</p>
<table>
<tr><th>Argument</th><th>Description</th><th>Default</th></tr>
<tr><td>url</td><td>The URL to navigate to</td><td>Required</td></tr>
<tr><td>reference_text</td><td>Text to use as reference point</td><td>Required</td></tr>
<tr><td>target_element_type</td><td>Type of element to find</td><td>Required</td></tr>
<tr><td>max_distance</td><td>Maximum distance in pixels</td><td>200</td></tr>
<tr><td>direction</td><td>Direction to search</td><td>any</td></tr>
<tr><td>confidence_threshold</td><td>Minimum confidence threshold</td><td>0.5</td></tr>
<tr><td>scan_full_page</td><td>Whether to scan the full page</td><td>True</td></tr>
</table>
<div class="example">
<pre><code>${result}=    Detect Element By Proximity    https://example.com    Password    input    150    right</code></pre>
</div>
<h4>Detect Icon By Image</h4>
<p>Detects an icon by comparing with a reference image.</p>
<table>
<tr><th>Argument</th><th>Description</th><th>Default</th></tr>
<tr><td>url</td><td>The URL to navigate to</td><td>Required</td></tr>
<tr><td>icon_image_path</td><td>Path to the reference icon image</td><td>Required</td></tr>
<tr><td>confidence_threshold</td><td>Minimum confidence threshold</td><td>0.5</td></tr>
<tr><td>scan_full_page</td><td>Whether to scan the full page</td><td>True</td></tr>
</table>
<div class="example">
<pre><code>${result}=    Detect Icon By Image    https://example.com    /path/to/search_icon.png    0.8</code></pre>
</div>
<h3>Mots-clés utilitaires</h3>
<h4>Get Element XPath</h4>
<p>Extracts the XPath from a detection result.</p>
<pre><code>${xpath}=    Get Element XPath    ${result}</code></pre>
<h4>Get Element Info</h4>
<p>Gets detailed DOM element information from a detection result.</p>
<pre><code>${info}=    Get Element Info    ${result}</code></pre>
<h4>Get Detection Confidence</h4>
<p>Gets the confidence score from a detection result.</p>
<pre><code>${confidence}=    Get Detection Confidence    ${result}</code></pre>
<h4>Close Browser</h4>
<p>Closes the browser and cleans up resources.</p>
<pre><code>Close Browser</code></pre>
<h2 id="architecture">Internal Architecture &amp; Helper Functions</h2>
<p>This section details the internal helper functions that power the primary detection keywords. Understanding these components helps with customization and troubleshooting.</p>
<h3>Core Detection Pipeline</h3>
<div class="pipeline">
<div class="pipeline-step">Browser Setup</div>
<span class="arrow">→</span>
<div class="pipeline-step">Screenshot Capture</div>
<span class="arrow">→</span>
<div class="pipeline-step">YOLO Detection</div>
<span class="arrow">→</span>
<div class="pipeline-step">DOM Element Matching</div>
<span class="arrow">→</span>
<div class="pipeline-step">Result Processing</div>
</div>
<h3>Browser &amp; Navigation Functions</h3>
<h4>_setup_driver()</h4>
<p>Initializes Chrome WebDriver with optimized settings for UI detection.</p>
<div class="info">
<h4>Key Configurations</h4>
<ul>
<li>English language preference (<code>--lang=en-US</code>)</li>
<li>Fixed window size (1920x1080) for consistent detection</li>
<li>Disabled GPU acceleration for stability</li>
<li>Sandbox disabled for Docker/CI environments</li>
</ul>
</div>
<pre><code>def _setup_driver(self):
    chrome_options = Options()
    chrome_options.add_argument("--lang=en-US")
    chrome_options.add_argument("--window-size=1920,1080")
    chrome_options.add_experimental_option("prefs", {
        "intl.accept_languages": "en-US,en"
    })</code></pre>
<h3>Screenshot Management Functions</h3>
<h4>_take_screenshot()</h4>
<p>Captures a single viewport screenshot and converts it to numpy array for YOLO processing.</p>
<div class="info">
<h4>Process</h4>
<ol>
<li>Saves PNG screenshot to disk with sequential naming</li>
<li>Loads image with OpenCV</li>
<li>Converts BGR to RGB color space (YOLO requirement)</li>
<li>Returns both numpy array and file path</li>
</ol>
</div>
<h4>_get_page_dimensions()</h4>
<p>Calculates page scrolling parameters using JavaScript execution.</p>
<table>
<tr><th>Return Value</th><th>Description</th></tr>
<tr><td>pageHeight</td><td>Total scrollable height</td></tr>
<tr><td>viewportHeight</td><td>Visible area height</td></tr>
<tr><td>currentScrollY</td><td>Current scroll position</td></tr>
</table>
<h4>_take_full_page_screenshots()</h4>
<p>Implements intelligent full-page scanning with overlapping regions.</p>
<div class="info">
<h4>Algorithm</h4>
<ol>
<li>Calculate step size with configurable overlap (default 10%)</li>
<li>Scroll through page in calculated increments</li>
<li>Handle edge cases (short pages, final screenshot positioning)</li>
<li>Return list of (image, path, scroll_offset) tuples</li>
</ol>
<p><strong>Overlap Strategy:</strong> Ensures no UI elements are missed between screenshot boundaries by overlapping adjacent captures.</p>
</div>
<h3>YOLO Detection Functions</h3>
<h4>_run_yolo_detection()</h4>
<p>Executes YOLO inference on screenshot images.</p>
<div class="info">
<h4>Process</h4>
<ol>
<li>Run model inference on RGB image array</li>
<li>Extract bounding boxes, confidence scores, and class predictions</li>
<li>Filter by optional class whitelist</li>
<li>Convert coordinates to integer pixels</li>
<li>Return structured detection list</li>
</ol>
</div>
<pre><code># Detection Structure
{
    'class_name': 'button',
    'confidence': 0.87,
    'bbox': (x1, y1, x2, y2)  # pixel coordinates
}</code></pre>
<h4>_adjust_bbox_for_scroll()</h4>
<p>Transforms bounding box coordinates from viewport space to absolute page coordinates.</p>
<pre><code>def _adjust_bbox_for_scroll(self, bbox, scroll_offset):
    x1, y1, x2, y2 = bbox
    return (x1, y1 + scroll_offset, x2, y2 + scroll_offset)</code></pre>
<h3>DOM Element Discovery Functions</h3>
<h4>_get_elements_in_bbox()</h4>
<p>Finds all DOM elements intersecting with a detected bounding box.</p>
<div class="info">
<h4>Multi-Method Approach</h4>
<ol>
<li><strong>Point Detection:</strong> Uses <code>document.elementFromPoint()</code> for center point</li>
<li><strong>Area Intersection:</strong> Checks all page elements for bbox overlap</li>
<li><strong>Geometric Filtering:</strong> Eliminates elements with insufficient overlap</li>
</ol>
</div>
<pre><code>// Executed via Selenium
var elements = [];
var allElements = document.querySelectorAll('*');

for (var i = 0; i &lt; allElements.length; i++) {
    var elemRect = allElements[i].getBoundingClientRect();
    if (elemRect.left &lt; x2 &amp;&amp; elemRect.right &gt; x1 &amp;&amp; 
        elemRect.top &lt; y2 &amp;&amp; elemRect.bottom &gt; y1) {
        elements.push({
            element: allElements[i],
            rect: { /* bounding rect data */ }
        });
    }
}</code></pre>
<h4>_get_elements_in_bbox_with_scroll()</h4>
<p>Handles element detection across different scroll positions.</p>
<div class="info">
<h4>Smart Scrolling Logic</h4>
<ol>
<li>Calculate element visibility in current viewport</li>
<li>Auto-scroll to center element if not visible</li>
<li>Adjust coordinates for new scroll position</li>
<li>Delegate to standard bbox detection</li>
</ol>
</div>
<h3>XPath &amp; Element Information Functions</h3>
<h4>_get_xpath()</h4>
<p>Generates robust XPath selectors for detected elements.</p>
<div class="info">
<h4>XPath Generation Strategy</h4>
<ol>
<li><strong>ID Priority:</strong> Use <code>id</code> attribute if available (<code>//*[@id="element-id"]</code>)</li>
<li><strong>Hierarchical Fallback:</strong> Build path from document root</li>
<li><strong>Sibling Indexing:</strong> Handle elements without unique identifiers</li>
</ol>
</div>
<h4>_get_element_info()</h4>
<p>Extracts comprehensive DOM element metadata.</p>
<div class="info">
<h4>Collected Properties</h4>
<ul>
<li><strong>Basic:</strong> <code>tagName</code>, <code>id</code>, <code>className</code>, <code>text</code>, <code>value</code></li>
<li><strong>Form-specific:</strong> <code>placeholder</code>, <code>type</code>, <code>name</code>, <code>checked</code>, <code>selected</code></li>
<li><strong>Link/Media:</strong> <code>href</code>, <code>src</code>, <code>alt</code>, <code>title</code></li>
<li><strong>All attributes</strong> as key-value pairs</li>
<li><strong>Bounding rectangle</strong> coordinates</li>
</ul>
</div>
<h3>Text Matching &amp; Similarity Functions</h3>
<h4>_text_similarity()</h4>
<p>Implements fuzzy text matching for robust element identification.</p>
<div class="info">
<h4>Matching Levels</h4>
<ol>
<li><strong>Exact Match:</strong> <code>text1 == text2</code> → 1.0 score</li>
<li><strong>Substring Match:</strong> One text contains the other → 0.8 score</li>
<li><strong>Word Overlap:</strong> Jaccard similarity on word sets → variable score</li>
</ol>
</div>
<pre><code>def _text_similarity(self, text1, text2):
    text1, text2 = text1.lower().strip(), text2.lower().strip()
    
    if text1 == text2: return 1.0
    if text1 in text2 or text2 in text1: return 0.8
    
    words1, words2 = set(text1.split()), set(text2.split())
    intersection = words1.intersection(words2)
    union = words1.union(words2)
    
    return len(intersection) / len(union) if union else 0.0</code></pre>
<h3>Label Detection Strategies</h3>
<p>The library employs multiple strategies to find labels associated with form elements:</p>
<div class="feature-grid">
<div class="feature-card">
<h4>Method 1: Direct Association</h4>
<pre><code>label[for='element-id']</code></pre>
</div>
<div class="feature-card">
<h4>Method 2: Parent Container</h4>
<pre><code>&lt;label&gt;&lt;input&gt;&lt;/label&gt;</code></pre>
</div>
<div class="feature-card">
<h4>Method 3: Spatial Proximity</h4>
<pre><code>distance &lt; 100px</code></pre>
</div>
<div class="feature-card">
<h4>Method 4: Placeholder Text</h4>
<pre><code>placeholder attribute</code></pre>
</div>
</div>
<h2 id="result-structure">Structure du résultat de détection</h2>
<p>All detection keywords return a dictionary with the following structure:</p>
<pre><code>{
    'xpath': '//*[@id="submit-btn"]',
    'dom_element': {
        'tagName': 'BUTTON',
        'id': 'submit-btn',
        'className': 'btn btn-primary',
        'text': 'Submit Form',
        'type': 'submit',
        # ... additional DOM properties
    },
    'confidence': 0.87,
    'bbox': (100, 200, 300, 250),  # x1, y1, x2, y2
    'screenshot_path': 'screenshots/screenshot_1.png',
    'annotated_screenshot_path': 'screenshots/screenshot_1_annotated.png'
}</code></pre>
<div class="warning">
<h4>Remarque</h4>
<p>If no element is found, the keywords return <code>None</code>.</p>
</div>
<h2 id="examples">Exemples de tests complets</h2>
<h3>Complete Form Automation</h3>
<pre><code>*** Settings ***
Library    UIElementDetectorRF    models/ui_model.pt    drivers/chromedriver.exe

*** Variables ***
${URL}    https://example-form.com
${EMAIL}    test@example.com
${PASSWORD}    mypassword

*** Test Cases ***
Complete Form Automation
    [Documentation]    Demonstrates complete form automation using visual detection
    
    # Detect and fill email field
    ${email_field}=    Detect Input By Label    ${URL}    Email Address    0.6
    Should Not Be Equal    ${email_field}    ${None}
    ${email_xpath}=    Get Element XPath    ${email_field}
    Input Text    ${email_xpath}    ${EMAIL}
    
    # Detect and fill password field
    ${password_field}=    Detect Element By Proximity    ${URL}    Password    input    200    any    0.6
    Should Not Be Equal    ${password_field}    ${None}
    ${password_xpath}=    Get Element XPath    ${password_field}
    Input Text    ${password_xpath}    ${PASSWORD}
    
    # Detect and check agreement checkbox
    ${checkbox}=    Detect Checkbox Radio By Text    ${URL}    I agree to terms    checkbox    0.7
    Should Not Be Equal    ${checkbox}    ${None}
    ${checkbox_xpath}=    Get Element XPath    ${checkbox}
    Select Checkbox    ${checkbox_xpath}
    
    # Detect and click submit button
    ${submit_btn}=    Detect Button By Text    ${URL}    Submit    0.8
    Should Not Be Equal    ${submit_btn}    ${None}
    ${submit_xpath}=    Get Element XPath    ${submit_btn}
    Click Element    ${submit_xpath}
    
    # Cleanup
    Close Browser</code></pre>
<h2 id="configuration">Options de configuration</h2>
<h3>Confidence Thresholds</h3>
<table>
<tr><th>Range</th><th>Description</th><th>Use Case</th></tr>
<tr><td>0.5-0.6</td><td>Permissive - May detect more elements but with potential false positives</td><td>Exploratory testing, difficult-to-detect elements</td></tr>
<tr><td>0.7-0.8</td><td>Balanced - Good balance between detection rate and accuracy</td><td>Production testing, most common use case</td></tr>
<tr><td>0.9+</td><td>Strict - High accuracy but may miss some valid elements</td><td>Critical operations, high-precision requirements</td></tr>
</table>
<h3>Scan Modes</h3>
<div class="feature-grid">
<div class="feature-card">
<h4>Full Page (True)</h4>
<p>Scrolls through entire page, best for comprehensive detection. Takes longer but finds elements anywhere on the page.</p>
</div>
<div class="feature-card">
<h4>Viewport Only (False)</h4>
<p>Scans only visible area, faster but may miss elements outside current view.</p>
</div>
</div>
<h3>Direction Options for Proximity Detection</h3>
<table>
<tr><th>Direction</th><th>Description</th><th>Example Use Case</th></tr>
<tr><td>any</td><td>Search in all directions</td><td>General proximity search</td></tr>
<tr><td>right</td><td>Element must be to the right of reference text</td><td>Form fields with left-aligned labels</td></tr>
<tr><td>left</td><td>Element must be to the left of reference text</td><td>Checkboxes with right-aligned labels</td></tr>
<tr><td>below</td><td>Element must be below reference text</td><td>Stacked form layouts</td></tr>
<tr><td>above</td><td>Element must be above reference text</td><td>Footer elements above copyright text</td></tr>
</table>
<h2 id="output">Fichiers de sortie</h2>
<p>The library automatically creates several types of output files for debugging and documentation:</p>
<div class="feature-grid">
<div class="feature-card">
<h4>📁 screenshots/</h4>
<p>Directory containing all captured screenshots with sequential naming</p>
</div>
<div class="feature-card">
<h4>📸 screenshot_N.png</h4>
<p>Original screenshots without annotations for reference</p>
</div>
<div class="feature-card">
<h4>🖼️ screenshot_N_annotated.png</h4>
<p>Screenshots with bounding boxes and confidence scores overlaid</p>
</div>
<div class="feature-card">
<h4>📄 full_page_annotated_N.png</h4>
<p>Combined full-page screenshots with all detections marked</p>
</div>
</div>
<h2 id="troubleshooting">Dépannage</h2>
<h3>Problèmes courants</h3>
<div class="warning">
<h4>"YOLO model not loaded" Error</h4>
<p>Ensure model path is correct and file exists. Verify the model file is a valid YOLO .pt file trained for UI elements.</p>
</div>
<div class="warning">
<h4>ChromeDriver Issues</h4>
<p>Update ChromeDriver to match your Chrome version. Ensure chromedriver is in PATH or provide full path during initialization.</p>
</div>
<div class="info">
<h4>Low Detection Rates</h4>
<ul>
<li>Lower confidence threshold (try 0.5-0.6)</li>
<li>Enable full page scanning</li>
<li>Check if elements are visually similar to training data</li>
<li>Verify element text matches expected patterns</li>
</ul>
</div>
<div class="info">
<h4>False Positives</h4>
<ul>
<li>Increase confidence threshold (try 0.8-0.9)</li>
<li>Use more specific text matching</li>
<li>Combine multiple detection strategies</li>
<li>Implement additional validation logic</li>
</ul>
</div>
<h3>Bonnes pratiques</h3>
<div class="example">
<h4>Model Training</h4>
<p>Train your YOLO model on UI elements similar to your target applications for better accuracy.</p>
</div>
<div class="example">
<h4>Confidence Tuning</h4>
<p>Start with 0.7 and adjust based on your results. Monitor false positives vs detection rate.</p>
</div>
<div class="example">
<h4>Text Matching</h4>
<p>Use distinctive, unique text for better matching. Avoid generic terms like "Submit" or "Click here".</p>
</div>
<div class="example">
<h4>Error Handling</h4>
<p>Always check if detection results are not None before using. Implement fallback strategies.</p>
</div>
<div class="example">
<h4>Resource Cleanup</h4>
<p>Always call <code>Close Browser</code> in test teardown to prevent memory leaks and browser processes.</p>
</div>
<h2 id="model-requirements">Exigences du modèle</h2>
<p>Your YOLO model should be trained to detect these classes for optimal performance:</p>
<div class="feature-grid">
<div class="feature-card">
<h4>🔘 button</h4>
<p>Standard buttons, submit buttons, action buttons</p>
</div>
<div class="feature-card">
<h4>📝 input / textbox</h4>
<p>Text inputs, password fields, search boxes</p>
</div>
<div class="feature-card">
<h4>📋 select / dropdown / combobox</h4>
<p>Select elements, dropdown menus, combo boxes</p>
</div>
<div class="feature-card">
<h4>☑️ checkbox</h4>
<p>Checkbox input elements</p>
</div>
<div class="feature-card">
<h4>🔘 radio</h4>
<p>Radio button input elements</p>
</div>
<div class="feature-card">
<h4>🖼️ icon / image</h4>
<p>Icons, buttons with images, clickable images</p>
</div>
</div>
<div class="info">
<h4>Training Tips</h4>
<ul>
<li>Include diverse UI frameworks (Bootstrap, Material-UI, custom designs)</li>
<li>Train on different screen sizes and resolutions</li>
<li>Include various states (hover, disabled, focused)</li>
<li>Use data augmentation for better generalization</li>
</ul>
</div>
<h2 id="performance">Considérations sur les performances</h2>
<table>
<tr><th>Factor</th><th>Impact</th><th>Optimization</th></tr>
<tr><td>Full page scanning</td><td>Slower but comprehensive</td><td>Use viewport-only for performance-critical tests</td></tr>
<tr><td>Large pages</td><td>High memory usage</td><td>Consider chunked processing for very large pages</td></tr>
<tr><td>Multiple detections</td><td>Browser overhead</td><td>Reuse browser sessions when possible</td></tr>
<tr><td>Model complexity</td><td>Inference time</td><td>Use optimized models for production</td></tr>
<tr><td>Screenshot resolution</td><td>Processing time</td><td>Balance resolution vs speed requirements</td></tr>
</table>
<h3>Performance Optimization Strategies</h3>
<div class="feature-grid">
<div class="feature-card">
<h4>⚡ Browser Reuse</h4>
<p>Keep browser instances open between tests to reduce initialization overhead</p>
</div>
<div class="feature-card">
<h4>🎯 Selective Detection</h4>
<p>Use class filters to detect only required element types</p>
</div>
<div class="feature-card">
<h4>📏 Smart Cropping</h4>
<p>Process only relevant page sections when element location is known</p>
</div>
<div class="feature-card">
<h4>🔄 Caching</h4>
<p>Cache screenshots and detection results for repeated operations</p>
</div>
</div>
<h2 id="integration">Intégration avec les tests existants</h2>
<p>This library can be seamlessly integrated with existing Robot Framework tests using hybrid approaches:</p>
<h3>Fallback Strategy</h3>
<pre><code>*** Test Cases ***
Hybrid Approach
    # Try traditional locator first
    ${status}=    Run Keyword And Return Status    Click Element    id=submit-btn
    Run Keyword If    not ${status}    Fallback To Visual Detection
    
*** Keywords ***
Fallback To Visual Detection
    ${result}=    Detect Button By Text    ${URL}    Submit    0.7
    Should Not Be Equal    ${result}    ${None}
    ${xpath}=    Get Element XPath    ${result}
    Click Element    ${xpath}</code></pre>
<h3>Element Verification</h3>
<pre><code>*** Keywords ***
Verify Element Exists Visually
    [Arguments]    ${element_text}    ${element_type}=button
    ${result}=    Run Keyword If    '${element_type}' == 'button'
    ...    Detect Button By Text    ${URL}    ${element_text}    0.6
    ...    ELSE    Detect Element By Proximity    ${URL}    ${element_text}    ${element_type}
    Should Not Be Equal    ${result}    ${None}
    [Return]    ${result}</code></pre>
<h3>Dynamic Element Discovery</h3>
<pre><code>*** Test Cases ***
Dynamic Form Filling
    [Documentation]    Automatically discover and fill form elements
    @{form_fields}=    Create List    Email    Password    First Name    Last Name
    
    FOR    ${field}    IN    @{form_fields}
        ${input_result}=    Detect Input By Label    ${URL}    ${field}    0.7
        Continue For Loop If    ${input_result} == ${None}
        ${xpath}=    Get Element XPath    ${input_result}
        Input Text    ${xpath}    test_${field.lower().replace(' ', '_')}
    END</code></pre>
<h2 id="advanced-usage">Modèles d'utilisation avancés</h2>
<h3>Custom Detection Logic</h3>
<pre><code>*** Keywords ***
Smart Button Detection
    [Arguments]    ${url}    ${button_text}    ${max_attempts}=3
    FOR    ${attempt}    IN RANGE    1    ${max_attempts + 1}
        ${result}=    Detect Button By Text    ${url}    ${button_text}    0.6
        Exit For Loop If    ${result} != ${None}
        
        # Try with lower confidence on subsequent attempts
        ${confidence}=    Evaluate    0.6 - (${attempt} * 0.1)
        ${result}=    Detect Button By Text    ${url}    ${button_text}    ${confidence}
        Exit For Loop If    ${result} != ${None}
        
        Log    Attempt ${attempt} failed, retrying...
        Sleep    1s
    END
    
    Should Not Be Equal    ${result}    ${None}    
    ...    Could not detect button '${button_text}' after ${max_attempts} attempts
    [Return]    ${result}</code></pre>
<h3>Multi-Strategy Detection</h3>
<pre><code>*** Keywords ***
Find Element Multiple Ways
    [Arguments]    ${url}    ${element_text}
    
    # Strategy 1: Direct button detection
    ${result}=    Run Keyword And Return Status    
    ...    Detect Button By Text    ${url}    ${element_text}    0.7
    Return From Keyword If    ${result}    ${result}
    
    # Strategy 2: Proximity detection
    ${result}=    Run Keyword And Return Status
    ...    Detect Element By Proximity    ${url}    ${element_text}    button    300
    Return From Keyword If    ${result}    ${result}
    
    # Strategy 3: Lower confidence
    ${result}=    Detect Button By Text    ${url}    ${element_text}    0.5
    Should Not Be Equal    ${result}    ${None}    Element not found with any strategy
    [Return]    ${result}</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>UIElementDetectorRF represents a significant advancement in web automation testing by combining the power of computer vision with traditional DOM manipulation. This approach provides robust, maintainable test automation that can adapt to UI changes while maintaining high reliability.</p>
<div class="info">
<h4>Key Benefits</h4>
<ul>
<li><strong>Resilient to UI Changes:</strong> Visual detection continues working even when underlying HTML structure changes</li>
<li><strong>Natural Language Interface:</strong> Find elements by their visible text rather than technical attributes</li>
<li><strong>Comprehensive Coverage:</strong> Full-page scanning ensures no elements are missed</li>
<li><strong>Self-Documenting:</strong> Annotated screenshots provide visual test documentation</li>
<li><strong>Flexible Integration:</strong> Works alongside existing Robot Framework tests</li>
</ul>
</div>
<p>This library bridges the gap between human perception of web interfaces and automated testing, enabling more intuitive and maintainable test automation solutions.</p>
<div class="feature-card" style="text-align: center; margin-top: 40px; background: linear-gradient(135deg, var(--gradient-1));">
<h4 style="color: white; margin-bottom: 15px;">Ready to Get Started?</h4>
<p style="color: rgba(255,255,255,0.9); margin-bottom: 0;">Download UIElementDetectorRF and transform your web automation testing with AI-powered element detection.</p>
</div>


</body>
</html>